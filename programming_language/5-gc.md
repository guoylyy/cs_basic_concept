# 垃圾回收机制

整理者：@globit

## 引言

垃圾回收机制是现代面向对象编程语言当中比较重要的一个特性，由于这个功能，真正地解放了程序员的生产力，让编程的门槛能够有效降低。可以说，如果没有这个机制，没有这么多的编程语言提供这么优越的编程环境，那么就不会有这一个 it 技术爆发的年代的来临。这里扯远了，撤回来。

垃圾回收之所以存在是是因为我们的内存空间不是无限的，当我们的程序在运行过程中，会产生大量的**永远不会再用到** 的对象也好，空间也好，这里我们就可以把它们作为垃圾看待，而这些垃圾占领者茅坑不拉屎，所以我们要坚决地将其清除出革命队伍。

那么问题就来了，垃圾回收的关键，当然是宁可放过一百个坏人，也不错抓一个好人，因为你回收了一些还会用到的对象，那么问题就大大了，进入我们熟悉的 null pointer 问题了。

所以我们聪明的程序语言设计者们就使出浑身解数，来让垃圾回收可以高效，快速，准确。

## 几种垃圾回收机制

既然要回收，就要有规矩，前人程序猿们在实现这个机制的时候，也是从无到有到优化创造出来的，所以我们就从最简单的开始看，看看这条技术路上的各种坑。

### 标记清除回收方式
所谓标记回收，是最容易想到的一种方式，我们内存中又一堆对象，他们之间可能有引用方式，那么怎么办呢？

1. 第一步，我们直接一个迭代或者一个递归（这个概念不明白的捂脸复习去！），如果这个对象被其他对象引用，就开始打上标记，比如设置一个标识位；如果他引用了其他变量，那么那个变量迭代时候也打上标识，这样，一轮下来，我们就知道哪些是活蹦乱跳的对象，哪些是寿终正寝的对象了。
2. 第二步，再迭代或者递归一遍，把死的对象清除掉，活的对象的标识归位。

其实这种做法很傻的拉，不过刚开始出现 gc 的时候，有这种做法已经很牛逼了，咱们先实现功能再考虑性能才是正道啊，人间程序是沧桑，码农何必为难码农。-_-!!

### 复制收集方式

标记清除方式是基本实现了垃圾回收，但是缺点也比较明显，我们需要扫描两次，如果待扫描的对象多了，这是一件非常肉疼的事情。

```
这个时候有的童鞋会问了： 为什么不在第一次扫描的时候就清除呢？

答曰：因为当遍历到当前对象的时候是无法判断这个对象是不是真的没有被引用了，需要遍历到其他对象才可以判断（如果你是个美女，你没看上别人，不代表没有人没看上你对吧，所以你不去挖出别人的心看看，遍历一遍，如何知道你有没有被别人看上呢？）
```

所以聪明的人们又想出了一种方法，在内存中开辟一块新内存，一旦第一次扫描的时候发现被引用的对象，就复制过去，搬砖的干活，黑吸。最后没有被搬的可怜对象们，就一起clear掉了，不带走一丝云彩。

这样做的好处无非有二：

1. 省事，直接清除一块内存中所有对象，比遍历后一个个清除方便和快速无痛苦更多；
2. 复制过去的对象往往在内存中离得更近了，以后访问起来效率可以提高（这可以算一个bonus吧）

### 引用计数方式

作为我主业 Java 里使用的方式，放在后面介绍有种大招的感觉。

这个思想也很简单：

1. 一个对象里存放了一个被多少对象引用的计数
2. 一旦 A 不再引用 B 了，B 的引用计数就减少
3. 当引用计数为 0 的时候，干掉

我们可以看到，太他妈简单了，无非就是操作对象的时候多多计数，多多计数，然后判断为 0 的时候回收呗。一来不需要循环扫描对象了，二来释放时间十分短暂。

但是福兮祸之所倚啊：

1. 无法释放循环引用的对象，你爱他，他爱她，她爱你（这里后面说明）
2. 容错性比较差，如果一旦减少错误了，对象永远释放不了了
3. 并行计算环境下必须使用独占锁来搞，效率可想而知

使用的语言：**Python  Java  Perl**, 其实都是配合使用，实际的实现都是混合各种方式的


## 放大招
上面的方式看起来已经很好啊，可是优化是子子孙孙无穷尽也的，程序员失业不了，所以赶快培养小孩写程序吧，哈哈哈。下面来讨论一下垃圾回收的几个大招，他们协同了很多种的

### 大招1，分代回收

基本思想也很简单，把对象分成新生代和老生代，新生代的优先扫描回收，老生代的很久才回收一下。

回收的算法大部分场景采用了复制回收，少部分采用了标记清除，每次扫描过后，有幸留下来的对象就是老生代对象了。 —— 大回收

然后后面的扫描就很简单了，只扫描新生代的回收叫**小回收**，扫描全部区域对象的叫**大回收**。

这里值得注意的是，小回收中需要用一个记录集记录老生代对新生代的引用，避免错误回收了新生代的对象。

### 大招2：增量回收

以上所述的回收都有一个问题，如果一个对象回收的时间太长，必然会阻塞程序的运行，那么如何保证程序的实时性呢？

增量回收把回收的过程渐进了，（这一点不太明白如何实现），猜想是在回收过程中还保存了对象的实例，而在空闲的时候删除掉，并且删除的时候调用了一个一定范围内时间的中断。

这样解决了实时性的问题，实现起来比较复杂。但是造成了中断的次数的增多，总时间的增加。好处是换取了一个可预测的回收中断时间。


### 大招3：并行回收

和增量回收大体相同，不过是用了多 cpu，实现起来更为复杂，现在貌似很少有实际应用，对并行感兴趣的同学可以研究一下。






