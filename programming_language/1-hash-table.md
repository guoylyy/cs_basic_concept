# 1-哈希表

## 原理
哈希表是一种数据存储结构，在大多数的情况下，其查找的效率是非常高的，甚至可能接近常数，而代价是消耗一些内存，是典型的空间换时间的做法。

哈希表是通过一组哈希散列函数的映射，找到键值存放的地址，其中，存放具体数据的数组叫做散列表，映射函数叫做散列函数。

![img](http://images.cnitblog.com/blog/361393/201311/22151330-e9e9dac6bc474da1bedcd908fc2baeb2.png)

## 地址获取方法

目的是根据一个关键字计算过后得到的结果均与散列在一个范围之内。

1. 线性函数定地址：不会产生冲突，废话，线性函数
2. 除留余数法：Hash(K) = K mod C
3. 数字分析法： 取关键字中均匀的数字，举例：比如员工生日，前面的年月日差距太小，不适合作为映射值，而后面的具体日期或者身份证的后面几位就差距比较大，这样作为映射值就会有效减少冲突。
4. 平方中间值： 取内部数字号的平方之间的中间几位来算地址值，因为中间几位与数字的每一位都有关系。


## 冲突

冲突发生的原因是由于两个不同的key，通过哈希表的散列函数计算，得到了相同的结果，这样一来，就会发生冲突。

冲突的界定： 

1. 填装因子，尼玛就是已存入的值和总地址空间容量的比值，比较容易理解
                       
2. 映射函数的选择,如果选择得不好，容易计算出相同的哈希值，那么冲突概率会大大增加

解决方法： 

1. 开放定地址： 把冲突地址带入到函数中再次计算，得到一个闲散的地址，感觉是递归计算直到得到合适的地址为止

2. 链表：发生冲突后把存储地址的数据结构搞成一个链表，这样就可以无限存储下去了，但是问题在于如何定位

![img](http://images.cnitblog.com/blog/361393/201311/22153526-b91c8808b77f44eca1b480210915bbea.png)



## Java 哈希表的实现
参考 C# 语言的实现, java 实现类似: [也谈哈希表](http://blog.csdn.net/yu0089/article/details/16889145)


## 应用范围
* 当需要频繁查找一个元素是否在已知集合中的时候，使用一个适宜规模的哈希表，会得到比较好的效率。
* 当需要频繁对一组对象中关于某一个关键属性查找时


参考：

1. [也谈哈希表](http://blog.csdn.net/yu0089/article/details/16889145)

2. [哈希工作原理](http://blog.csdn.net/nju_yaho/article/details/7402208)

3. [哈希表（百度）](http://baike.baidu.com/link?url=aDkVzmv-NUgPcohelnEFZE2cJecajRQXJactbQwBxUPfF7J-BRJWAr2g_eYlWIbH-CJsee0ex-L-rULkFX-Jwq)


